/**
 * Handles all the UI design of the replies generated by King.
 * The text decorations are all handled by the UI.
 * Long texts are automatically wrapped by the UI and texts
 * are wrapped with a buffer to maintain the words in the text.
 *
 * @author jun siang
 */
package ui;

import java.util.stream.IntStream;

import tasks.TaskList;

public class UI {

    // maximum number of characters across a screen
    public static final int CHAT_WIDTH = 50;

    // Buffer to wrap text to the next line if the text if too long.
    // This buffer helps to keep words intact while wrapping the text
    // to the next line.
    public static final int BUFFER = CHAT_WIDTH - 6;

    /**
     * Returns the Welcome message and logo.
     *
     * @return String welcome message.
     */
    public static String welcome() {
        String logo = " ___  __.__\n"
                + "|    |/ _|__|  __       ___\n"
                + "|      < |  |/ _  \\   /  __ \\\n"
                + "|    |   \\|  | |   \\ \\/  /_/   \\\n"
                + "|___|___\\__|   |  /\\__  /  /\n"
                + "                   \\//_____/";

        String message = "Hello! I'm King!\nWhat can I do for you?";
        return wrapBorderAroundText("#", "", "#", "    ", 20, logo, true)
                + "\n" + message;
    }

    /**
     * Returns a chat box for KING wrapped around a given text.
     *
     * @param chatContent text string.
     * @return String chat box around text.
     * @see king.King
     * @deprecated no longer in use after moving UI to javafx.
     */
    @Deprecated
    public static String kingChatBox(String chatContent) {
        return "\t" + printLine("King says", 5, "-", CHAT_WIDTH) + "\n\t"
                + formatStringIfLong(chatContent, "\n") + "\n"
                + "\t" + printLine("", null, "-", CHAT_WIDTH) + "\n";
    }

    /**
     * Returns an empty chat box.
     *
     * @param chatContent text string.
     */
    public static String emptyChatBox(String chatContent) {
        return chatContent;
    }

    /**
     * Returns an error box wrapped around an error message.
     *
     * @param error error message.
     * @return String error box around error message.
     */
    public static String errorBox(String error) {
        return printLine(" Error Encountered ", 4, "-", CHAT_WIDTH) + "\n"
                + formatStringIfLong(error, "\n");
    }

    /**
     * Returns a chat box wrap around a message when the user successfully adds an item.
     *
     * @param chatContent text String.
     * @param numOfItems  number of items in the new TaskList.
     * @return String chat box after adding item.
     * @see TaskList
     */
    public static String addItemChatBox(String chatContent, int numOfItems) {
        return emptyChatBox("Got it. I've added this task:\n"
                + "\t" + chatContent
                + "\nNow you have " + numOfItems + " tasks in the list.");
    }

    /**
     * Returns a chat box wrap around a message when the user successfully deletes tasks.
     *
     * @param itemsDeletedList taskList of the items deleted.
     * @param numOfItemsLeft   number of items left in the new TaskList.
     * @return String chat box around text.
     * @see TaskList
     */
    public static String deleteItemChatBox(int numOfItemsLeft, TaskList itemsDeletedList) {
        String formattedText = "";
        for (int i = 0; i < itemsDeletedList.size(); i++) {
            String item = itemsDeletedList.get(i).toString();
            formattedText += ("\t" + item + "\n");
        }
        return emptyChatBox("I have deleted the following item:\n"
                + formattedText
                + "You got " + numOfItemsLeft + " task(s) left.");
    }

    /**
     * Returns a chat box wrap around a message when the user sets an item as DONE.
     *
     * @param chatContent text String.
     * @return String chat box around text.
     * @see tasks.Task
     */
    public static String doneChatBox(String chatContent) {
        return emptyChatBox("Nice! I've marked this task as done:\n\t"
                + chatContent
        );
    }

    /**
     * Returns a formatted chat string containing the items in the TaskList.
     *
     * @param taskList the task list to be printed.
     * @return String formatted String with items in the taskList.
     */
    public static String showTaskList(TaskList taskList) {

        assert taskList != null : "showTaskList cannot be null!";

        StringBuilder formatted = new StringBuilder();
        int len = taskList.size();
        IntStream
                .range(0, len)
                .forEach(number -> formatted.append("\n\t  " + (number + 1) + ". " + taskList.get(number).toString()));
        return emptyChatBox("There are " + len + " items in your list:"
                + formatted.toString());
    }

    /**
     * Returns a formatted string containing items found in the list.
     *
     * @param taskList taskList of the items found.
     * @return String formatted printable list
     */
    public static String showFoundItems(TaskList taskList) {

        assert taskList != null : "taskList cannot be null!";

        StringBuilder formatted = new StringBuilder();
        int len = taskList.size();
        IntStream
                .range(0, len)
                .forEach(number -> formatted.append("\n\t  " + (number + 1) + ". " + taskList.get(number).toString()));
        return emptyChatBox("I found " + len + " items with the given keyword(s):"
                + formatted.toString());
    }

    // folds a string if it is too long to fit into the chat box
    private static String formatStringIfLong(String unformattedString, String delimiter) {
        int len = unformattedString.length();
        if (len > CHAT_WIDTH) {
            StringBuilder longString = new StringBuilder(unformattedString);
            int processedLength = 0;
            int pos = 0;
            while (pos != longString.length()) {
                char c = longString.charAt(pos);
                if (c == '\n') {
                    processedLength = 0;
                    pos++;
                } else if (c == '\t') {
                    pos++;
                } else if ((processedLength >= BUFFER && c == ' ') || processedLength == CHAT_WIDTH) {
                    longString.insert(pos, delimiter);
                    pos += 4;
                    processedLength = 1;
                } else if (processedLength == 0 && c == ' ') {
                    longString.deleteCharAt(pos);
                } else {
                    pos++;
                    processedLength++;
                }
            }
            return longString.toString();
        } else {
            return unformattedString;
        }
    }

    /**
     * Prints a line with the option to include a text in the middle
     * of the line.
     * @param text
     * @param posOfText
     * @param symbol
     * @param length
     * @return
     */
    private static String printLine(String text, Integer posOfText, String symbol, Integer length) {
        StringBuilder result = new StringBuilder();
        if (text == "") {
            for (int i = 0; i < length; i++) {
                result.append(symbol);
            }
        } else {
            for (int i = 0; i < posOfText; i++) {
                result.append(symbol);
            }
            result.append(text);
            while (result.length() < length) {
                result.append(symbol);
            }
        }
        return result.toString();
    }

    /**
     * wrap border around text
     *
     * @param top
     * @param right
     * @param bot
     * @param left
     * @param size
     * @param text
     * @param gotSideBorder
     * @return
     */
    private static String wrapBorderAroundText(String top, String right, String bot, String left,
                                               int size, String text, boolean gotSideBorder) {
        String topBorder = printLine("", null, top, size);
        String botBorder = printLine("", null, bot, size);
        StringBuilder input = new StringBuilder(text);
        StringBuilder output = new StringBuilder();
        output.append(topBorder);
        output.append("\n");
        if (gotSideBorder) {
            int processedLength = 0;
            int linePos = 0;
            while (processedLength < input.length()) {
                if (input.charAt(processedLength) == '\n') {
                    while (linePos < size - 1) {
                        output.append(" ");
                        linePos++;
                    }
                    output.append(right + "\n");
                    linePos = 0;
                } else {
                    if (linePos == 0) {
                        output.append(left);
                    }
                    output.append(input.charAt(processedLength));
                    linePos++;
                }
                processedLength++;
            }
        } else {
            output.append(text);
        }
        output.append("\n" + botBorder);
        return output.toString();
    }
}
